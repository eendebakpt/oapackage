Properties of designs
=====================

This section shows the statistical properties of the arrays and designs generated by the Orthogonal Array package. The values for most properties are available from the :class:`~oalib.array_link`
object. Most properties of an array can be calculated using the :class:`~oalib.array_link`
object. Some properties are calculated using a function from the package

For example to calculate the rank of an array and determine whether the array is a foldover array one can use:

.. code-block:: python
   
 >>> al=oapackage.exampleArray(1)
 >>> print(al.rank())
 5 
 >>> print(al.foldover())
 False

.. doxygenfunction:: array_link::rank
.. doxygenfunction:: array_link::foldover

The full set of methods can be found in the documentation of :class:`~oalib.array_link`.

Statistical properties of an array
----------------------------------

In :cite:`EendebakSO` designs capable of estimating the interaction model are generated. To determine the best of these designs
a set of efficiency criteria was used


.. doxygenfunction:: array_link::Defficiency
.. doxygenfunction:: array_link::DsEfficiency
.. doxygenfunction:: array_link::DsEfficiency
.. doxygenfunction:: array_link::Aefficiency
.. doxygenfunction:: array_link::Eefficiency


The :math:`D`-efficiency, :math:`A`-efficiency and :math:`E`-efficiency
are calculated by calculating the SVD of the second order interaction
matrix. The efficiencies can then be calculated using the eigenvalues of
the SVD. For the definition of the :math:`D`-, :math:`A`- and
:math:`E`-efficiency see Definition :ref:`DAE`. For the
rank of a matrix the LU decomposition of the matrix is calculated using
the Eigen package :cite:`eigenweb`.

.. topic:: Definition: D-efficiency and average VIF
   :name: DAE

   Let :math:`X` be an :math:`N\times k` :math:`2`-factor
   array with second order model :math:`{F(X)}`. Then we define the :math:`{D}`-efficiency and the average variance inflation factor as

   .. math::
    
       {D(X)} = \left( \det {F(X)}^T {F(X)}\right)^{1/m} / N , 
       \label{formula:Defficiency} \\
       {\mathrm{VIF}(X)} = N \operatorname{tr}\left( \frac{1}{ {F(X)}^T {F(X)}} \right) /m . \label{formula:VIF}
       
   The matrix :math:`{F(X)}^T {F(X)}` is called the information matrix. Let :math:`\lambda_1, \ldots, \lambda_m` be the eigenvalues of the information matrix. Then the :math:`{E}`-efficiency of a matrix is defined as

   .. math::
       
       {E(X)} = \min_j \lambda_j .
       \label{formula:E-efficiency}

Note that in terms of the eigenvalues we have
:math:`{D(X)} = (\prod_j \lambda_j)^{1/m} / N` and
:math:`{\mathrm{VIF}(X)} = N (\sum_j \lambda_j^{-1})/m`.

The :math:`D_s`-efficiency is the main effect robustness, see the appendix
in :cite:`Schoen2010` for more details.


Projection sequences
--------------------

For a design with N runs and k factors one often studies subdesigns with N runs and l factors. 
To determine the quality of a design for such projections one can use projection sequences.

    
.. doxygenfunction:: array_link::PECsequence
.. doxygenfunction:: PICsequence


GWLP and J-characteristics
--------------------------

From an :meth:`~oalib.array_link` object we can calculate the generalized
worldlength patterns :cite:`Xu2001`, :math:`F`-values and
:math:`J`-characteristics.

.. code-block:: python
 :caption: Calculate GWLP and :math:`F`-values 
   
 >>> al=oapackage.exampleArray(1)
 >>> al.showarray() array: 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 1 0 1 0 0 1 1 0 0 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 1 0 0 1 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0
 >>> g=al.GWLP()
 >>> print('print(’GWLP: %s’% str(g) )
 GWLP: (1.0, 0.0, 0.0, 1.0, 1.0, 0.0)
 >>> print('F3-value: %s' % str(al.Fvalues(3)))
 F3-value: (4, 6)
 >>> print('F4-value: %s' % str(al.Fvalues(4)))
 F4-value: (1, 4)
 >>> print('J3-characteristics: %s’ % str(al.Jcharacteristics(3)))
 J3-characteristics: (8, 8, 0, 0, 0, 8, 0, 8, 0, 0)

The documentation:

.. doxygenfunction:: array_link::GWLP
.. doxygenfunction:: array_link::Fvalues
.. doxygenfunction:: array_link::Jcharacteristics


MD5 sums
--------

To check data structures on disk the packages includes functions to
generate MD5 sums of designs. 

.. code-block:: python
 :caption: Calculate md5 sum of a design

 >>> import oapackage; al=oapackage.exampleArray(0)
 >>> al.md5()
 '6454c492239a8e01e3c01a864583abf2'

The C++ functions are:

.. doxygenfunction::  array_link::md5()
    :no-link:
.. doxygenfunction::  md5(void *, int)
    :no-link:
.. doxygenfunction::  md5(const std::string)
    :no-link:
    

    
