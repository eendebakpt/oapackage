Generation of designs
=====================

The OApackage can be used to generate several classes of arrays. A collection of
arrays generated by the package is available on the website http://www.pietereendebak.nl/oapackage/index.html.


The main functions:

.. autosummary::

        oapackage.Doptim.Doptimize
        oapackage.oalib.generateConferenceExtensions
        
        
Generation of orthogonal arrays
-------------------------------

A list of arrays in LMC form (i.e., lexicographically minimum in columns) can be extended to a list of arrays in LMC
form with one additional column. Details about the algorithm are described
in :cite:`Eendebak2009`.

The main functions for array extension are the following:

.. doxygenfunction:: extend_arraylist(const arraylist_t&, arraydata_t&, OAextend const&)
.. doxygenfunction:: extend_arraylist(const arraylist_t&, const arraydata_t&)

                     
Here, :meth:`~oalib.arraydata_t` is the structure describing the type of arrays and
:meth:`~oalib.OAextend` contains various options for the algorithm.

An example of a session is the following:

.. code-block:: python
   :caption: Extend an array
   
   >>> import oapackage
   >>> N=8; ncols=3;
   >>> arrayclass=oapackage.arraydata_t(2, N, 2, ncols)
   >>> root_array=arrayclass.create_root() 
   >>> root_array.showarraycompact()
   00
   00
   01
   01
   10
   10
   11
   11
   >>> array_list=oapackage.extend_array(root_array, arrayclass)
   >>> print('found %d extensions of the root array' % len(array_list))
   found 2 extensions of the root array

Even-odd
--------

The even-odd arrays are a special class of orthognal arrays with at least one of the odd :math:`J`-characteristics unequal to zero.
More information on this class of designs will appear later.

Conference designs
------------------

An :math:`n\times k` conference design is an :math:`N\times k` matrix
with entries 0, -1, +1 such that i) in each column the symbol 0 occurs
exactly one time and ii) all columns are orthogonal to each other.
For details see :cite:`EendebakSO`, :cite:`wiki:ConferenceMatrix`.

.. code-block:: python
 :caption: Generate conference designs with 8 rows
                    
 >>> import oapackage
 >>> ctype=oapackage.conference_t(N=8, k=8)
 >>> al = ctype.create_root_three()
 >>> al.showarray() array: 0 1 1 1 0 -1 1 1 0 1 1 1 1 1 -1 1 -1 1 1 -1 1 1 -1 -1
 >>> l4=oapackage.extend_conference ([al], ctype, verbose=0)
 >>> l5=oapackage.extend_conference ( l4, ctype,verbose=0) 
 >>> l6=oapackage.extend_conference ( l5, ctype, verbose=0)
 >>>
 >>> print('number of non-isomorphic conference designs: number of conference designs: %d'  % len(l6) )
 non-isomorphic conference designs: 11


The full interface for conference designs is available
in the :ref:`Interface for conference designs`.

.. comment 
    .. doxygenfile:: conference.h

Calculation of D-optimal designs
--------------------------------

D-optimal designs can be calculated with the function :py:meth:`oapackage.Doptim.Doptimize`.
This function uses a coordinate-exchange algorithm to generate designs
with good properties for the :math:`D`-efficiency.

A Python script to generate optimal designs with 40 runs and 7 factors is shown below.

.. code-block:: python
 :caption: Doptimize
 
 >>> N=40; s=2; k=7;
 >>> arrayclass=oapackage.arraydata_t(s, N, 0, k) 
 >>> print('We generate optimal designs with: %s' % arrayclass)
 We generate optimal designs with: arrayclass: N 40, k 7, strength 0, s 2,2,2,2,2,2,2, order 0.
 >>> alpha=[1,2,0] 
 >>> method=oapackage.DOPTIM_UPDATE 
 >>> scores, dds, designs, ngenerated = oapackage.Doptimize(arrayclass, nrestarts=40, optimfunc=alpha, selectpareto=True)
 Doptim: optimization class 40.2-2-2-2-2-2-2
 Doptimize: iteration 0/40
 Doptimize: iteration 39/40 Doptim: done (8 arrays, 0.6 [s]) 
 >>> print('Generated %d designs, the best D-efficiency is %.4fâ€™ % (len(designs), dds[:,0].max() ))
 Generated 8 designs, the best D-efficiency is 0.9098

The parameters of the :meth:`~oapackage.Doptim.Doptimize` function are documented in the code.

To calculate properties of designs we can use the following functions.
We can use the following command:

.. doxygenfunction:: array_link::Defficiencies(int)
    :no-link:

to calculate the :math:`D`-, :math:`D_s`- and :math:`D_1`-efficiency.
For details see :cite:`EendebakSO`.

The OApackage also allows to compute the projection estimation 
capacity (PEC) sequence for orthogonal arrays :cite:`loeppky2004ranking`. This can be calculated with the following command:

.. doxygenfunction:: PECsequence(const array_link&, int)
    :no-link:
    :outline:
.. doxygenfunction:: array_link::PECsequence()
    :no-link:
    :outline:
    
In :cite:`EendebakSO` it is shown that one can optimize a linear combination of the
:math:`D`-efficiency and :math:`D_s`-efficiency to generate a rich 
set of optimal designs with various efficiency. From the generated designs the optimal ones accoring
to Pareto optimality can be selected.


.. figure:: images/motivating-40-d-2-2-2-2-2-2-2-scatterplot-ndata2.png

   Scatterplot for the :math:`D`-efficiency and :math:`D_s`-efficiency
   for generated designs in :math:`{\operatorname{OA}(40; 2; 2^7)}`. The
   Pareto optimal designs are colored, while the non-Pareto optimal
   designs are grey. For reference the strength-3 orthogonal array with
   highest D-efficiency is also included in the plot.
