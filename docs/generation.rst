Generation of designs
=====================

The OApackage can be used to generate several classes of arrays. A collection of
arrays generated by the package is available on the website http://www.pietereendebak.nl/oapackage/index.html.
      
        
Generation of orthogonal arrays
-------------------------------

A list of arrays in LMC form (i.e., lexicographically minimum in columns) can be extended to a list of arrays in LMC
form with one additional column. Details about the algorithm are described
in :cite:`Eendebak2009`.

The main functions for array extension are the following:

.. doxygenfunction:: extend_arraylist(const arraylist_t&, const arraydata_t&)
    :outline:
.. doxygenfunction:: extend_arraylist(const arraylist_t&, arraydata_t&, OAextend const&)
    :outline:
                     
Here, :meth:`~oalib.arraydata_t` is the structure describing the class of arrays and
:meth:`~oalib.OAextend` contains various options for the algorithm.

An example of a session that extends a designs is:

.. .. code-block:: python
   :caption: Extend an array
.. doctest::
   
   >>> import oapackage
   >>> N=8; ncols=3;
   >>> arrayclass=oapackage.arraydata_t(2, N, 2, ncols)
   >>> root_array=arrayclass.create_root() 
   >>> root_array.showarraycompact()
   00
   00
   01
   01
   10
   10
   11
   11
   >>> array_list=oapackage.extend_array(root_array, arrayclass)
   >>> print('found %d extensions of the root array' % len(array_list))
   found 2 extensions of the root array

A more detailed example is :ref:`Enumerate orthogonal arrays`.

Conference designs
------------------

An :math:`n\times k` conference design is an :math:`N\times k` matrix
with entries 0, -1, +1 such that i) in each column the symbol 0 occurs
exactly one time and ii) all columns are orthogonal to each other.
For details see :cite:`Schoen2018dsd`, :cite:`wiki:ConferenceMatrix`.

.. admonition:: Generate conference designs with 8 rows

   .. doctest::     
                   
    >>> import oapackage
    >>> ctype=oapackage.conference_t(8, 8, 0) 
    >>> al = ctype.create_root_three()
    >>> al.showarray()
    array:
      0   1   1
      1   0  -1
      1   1   0
      1   1   1
      1   1  -1
      1  -1   1
      1  -1   1
      1  -1  -1
    >>> l4=oapackage.extend_conference ([al], ctype, verbose=0)
    >>> l5=oapackage.extend_conference ( l4, ctype,verbose=0) 
    >>> l6=oapackage.extend_conference ( l5, ctype, verbose=0)
    >>> print('number of non-isomorphic conference designs: %d'  % len(l6) )
    number of non-isomorphic conference designs: 11


An example notebook with more functionality is
:ref:`Generation and analysis of conference designs`.
The full interface for conference designs is available
in the :ref:`Interface for conference designs`.

The main functions to extend conference and double conference designs are
:cpp:func:`extend_conference` and :cpp:func:`extend_double_conference`.

The low-level functions for generating candidate extension columns of conference and double conference designs
are :cpp:func:`generateConferenceExtensions` and
:cpp:func:`generateDoubleConferenceExtensions`.


Calculation of D-optimal designs
--------------------------------

D-optimal designs can be calculated with the function :py:meth:`oapackage.Doptim.Doptimize`.
This function uses a coordinate-exchange algorithm to generate designs
with good properties for the :math:`D`-efficiency.

A Python script to generate optimal designs with 40 runs and 7 factors is shown below.

.. admonition:: Example of Doptimize usage

   .. testsetup::
   
       import oapackage
       
   .. .. code-block:: python

   .. doctest::  

     >>> N=40; s=2; k=7;
     >>> arrayclass=oapackage.arraydata_t(s, N, 0, k) 
     >>> print('We generate optimal designs with: %s' % arrayclass)
     We generate optimal designs with: arrayclass: N 40, k 7, strength 0, s {2,2,2,2,2,2,2}, order 0
     >>> alpha=[1,2,0] 
     >>> oapackage.seedfastrand(123)
     >>> oapackage.set_srand(123)
     >>> scores, dds, designs, ngenerated = oapackage.Doptimize(arrayclass, nrestarts=40, optimfunc=alpha, selectpareto=True, verbose=0)
     Doptimize: iteration 0/40
     Doptimize: iteration 39/40
     >>> print('Generated %d designs, the best D-efficiency is %.4f' % (len(designs), dds[:,0].max() ))
     Generated 10 designs, the best D-efficiency is 0.9198

The parameters of the :meth:`~oapackage.Doptim.Doptimize` function are documented in the code.

To calculate properties of designs we can use the following functions.
We can use the following command:

.. doxygenfunction:: array_link::Defficiencies(int)
    :no-link:

to calculate the :math:`D`-, :math:`D_s`- and :math:`D_1`-efficiency.
For details see :cite:`EendebakSO`.

The OApackage also allows to compute the projection estimation 
capacity (PEC) sequence for orthogonal arrays :cite:`loeppky2004ranking`.
This can be calculated with the following commands :meth:`~oalib.PECsequence` and :meth:`oalib.array_link.PECsequence`.

.. comment
    .. doxygenfunction:: PECsequence(const array_link&, int)
        :no-link:
        :outline:
    .. doxygenfunction:: array_link::PECsequence()
        :no-link:
        :outline:
    
In :cite:`EendebakSO` it is shown that one can optimize a linear combination of the
:math:`D`-efficiency and :math:`D_s`-efficiency to generate a rich 
set of optimal designs with various efficiency. From the generated designs the optimal ones accoring
to Pareto optimality can be selected.


.. figure:: images/motivating-40-d-2-2-2-2-2-2-2-scatterplot-ndata2.png

   Scatterplot for the :math:`D`-efficiency and :math:`D_s`-efficiency
   for generated designs in :math:`{\operatorname{OA}(40; 2; 2^7)}`. The
   Pareto optimal designs are colored, while the non-Pareto optimal
   designs are grey. For reference the strength-3 orthogonal array with
   highest D-efficiency is also included in the plot.

Even-odd
--------

The even-odd arrays are a special class of orthognal arrays with at least one of the odd :math:`J`-characteristics unequal to zero.
More information on this class of designs will appear later.
